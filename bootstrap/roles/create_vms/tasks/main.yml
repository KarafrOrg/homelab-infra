- name: Gather host facts
  setup:
    filter: ansible_*
  register: host_facts

- name: Calculate available resources with fallbacks
  set_fact:
    available_memory: "{{ ((ansible_memtotal_mb | default(8192)) | int * resource_allocation.memory_ratio) | int }}"
    available_cpus: "{{ ((ansible_processor_vcpus | default(4)) | int * resource_allocation.cpu_ratio) | int }}"

- name: Ensure minimum resources are available
  set_fact:
    available_memory: "{{ ([available_memory | int, 4096] | max) }}"
    available_cpus: "{{ ([available_cpus | int, 2] | max) }}"

- name: Calculate per-VM resources
  set_fact:
    vm_memory_per_instance: "{{ ((available_memory | int / (vms_per_host | int)) | int) | max(1024) }}"
    vm_cpus_per_instance: "{{ [1, ((available_cpus | int / (vms_per_host | int)) | int)] | max }}"

- name: Ensure libvirt is installed
  package:
    name: "{{ item }}"
    state: present
  become: yes
  loop:
    - libvirt-daemon
    - libvirt-daemon-system
    - qemu-system-x86
    - qemu-kvm
    - bridge-utils
    - virtinst
    - virt-manager

- name: Ensure libvirtd is started and enabled
  service:
    name: libvirtd
    state: started
    enabled: yes
  become: yes

- name: Ensure VM storage directory exists
  file:
    path: "{{ vm_storage_path }}"
    state: directory
    mode: '0755'
  become: yes

- name: Create VM configuration directory
  file:
    path: "/tmp/vm_configs"
    state: directory
    mode: '0755'

- name: Generate cloud-init user data for VMs
  template:
    src: cloud-init-user-data.j2
    dest: "/tmp/vm_configs/user-data-{{ item }}"
    mode: '0644'
  loop: "{{ range(1, vms_per_host + 1) | list }}"

- name: Create VMs with virt-install
  shell: |
    virt-install \
      --name {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} \
      --vcpus {{ vm_cpus_per_instance }} \
      --memory {{ vm_memory_per_instance }} \
      --disk path={{ vm_storage_path }}/{{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}.qcow2,size={{ vm_disk_size | regex_replace('[^0-9]', '') }},format=qcow2 \
      --network bridge={{ vm_bridge }},model=virtio \
      --os-type linux \
      --os-variant ubuntu22.04 \
      --cloud-init user-data=/tmp/vm_configs/user-data-{{ item }} \
      --graphics none \
      --console pty,target_type=serial \
      --noreboot
  become: yes
  become_user: root
  register: vm_creation
  loop: "{{ range(1, vms_per_host + 1) | list }}"
  ignore_errors: yes

- name: Start VMs
  shell: |
    virsh start {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}
  become: yes
  loop: "{{ range(1, vms_per_host + 1) | list }}"
  ignore_errors: yes

- name: Wait for VMs to get IP addresses
  shell: |
    virsh domifaddr {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} | grep -oP '[\d.]+(\.[\d.]+){3}' | head -1
  become: yes
  register: vm_ip_result
  until: vm_ip_result.stdout != ""
  retries: 30
  delay: 5
  loop: "{{ range(1, vms_per_host + 1) | list }}"

- name: Collect VM IP addresses
  set_fact:
    vm_ips: "{{ vm_ips | default([]) + [item.stdout] }}"
  loop: "{{ vm_ip_result.results }}"
  when: item.stdout is defined and item.stdout != ""

- name: Add VMs to dynamic inventory
  add_host:
    name: "{{ vm_base_name }}-{{ inventory_hostname }}-{{ item.0 }}"
    ansible_host: "{{ item.1 }}"
    ansible_user: ubuntu
    groups: k3s_cluster
  loop: "{{ range(1, vms_per_host + 1) | list | zip(vm_ips | default([])) | list }}"

- name: Wait for SSH connectivity on VMs
  wait_for:
    host: "{{ item }}"
    port: 22
    delay: 10
    timeout: 300
  loop: "{{ vm_ips | default([]) }}"
