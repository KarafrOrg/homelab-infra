- name: Debug incoming variables
  debug:
    msg: |
      vms_per_host value: {{ vms_per_host | default('USING DEFAULTS') }}
      Task vars context should have vms_per_host from include_role

- name: Set safe vms_per_host from explicit variable
  set_fact:
    vms_per_host_safe: "{{ (vms_per_host | int) }}"
  when: vms_per_host is defined and vms_per_host != ''

- name: Set safe vms_per_host from defaults (fallback)
  set_fact:
    vms_per_host_safe: "3"
  when: vms_per_host_safe is not defined

- name: Validate vms_per_host_safe is not zero
  assert:
    that:
      - vms_per_host_safe | int > 0
    fail_msg: "vms_per_host_safe must be greater than 0, got {{ vms_per_host_safe }}"

- name: Gather host facts
  setup:
    filter: ansible_*
  register: host_facts

- name: Calculate available resources with fallbacks
  set_fact:
    available_memory: "{{ ((ansible_memtotal_mb | default(8192)) | int * resource_allocation.memory_ratio) | int }}"
    available_cpus: "{{ ((ansible_processor_vcpus | default(4)) | int * resource_allocation.cpu_ratio) | int }}"

- name: Ensure minimum resources are available
  set_fact:
    available_memory: "{{ ([available_memory | int, 4096] | max) }}"
    available_cpus: "{{ ([available_cpus | int, 2] | max) }}"

- name: Debug resource calculation
  debug:
    msg: |
      Available Memory: {{ available_memory }} MB
      Available CPUs: {{ available_cpus }}
      VMs per host: {{ vms_per_host_safe }}

- name: Calculate per-VM resources
  set_fact:
    vm_memory_per_instance: "{{ ([((available_memory | int) / ([vms_per_host_safe | int, 1] | max)) | int, 1024] | max) }}"
    vm_cpus_per_instance: "{{ [1, (((available_cpus | int) / ([vms_per_host_safe | int, 1] | max)) | int)] | max }}"

- name: Display calculated VM resources
  debug:
    msg: |
      Memory per VM: {{ vm_memory_per_instance }} MB
      CPUs per VM: {{ vm_cpus_per_instance }}

- name: Update APT package cache
  apt:
    update_cache: yes
    cache_valid_time: 3600
  become: yes

- name: Fix broken apt dependencies
  shell: apt-get --fix-broken --fix-missing -y install
  become: yes
  ignore_errors: yes

- name: Ensure libvirt is installed
  package:
    name: "{{ item }}"
    state: present
  become: yes
  loop:
    - libvirt-daemon
    - libvirt-daemon-system
    - qemu-system-x86
    - qemu-kvm
    - bridge-utils
    - virtinst
    - virt-manager
  retries: 3
  delay: 5
  register: libvirt_install
  until: libvirt_install is succeeded

- name: Ensure libvirtd is started and enabled
  service:
    name: libvirtd
    state: started
    enabled: yes
  become: yes

- name: Check libvirt default network
  shell: virsh net-info default 2>&1 | grep -q "Active.*yes" && echo "active" || echo "inactive"
  become: yes
  register: default_net_check
  changed_when: false
  ignore_errors: yes

- name: Create default network if missing
  shell: |
    virsh net-define /dev/stdin <<'EOF'
    <network>
      <name>default</name>
      <forward mode='nat'>
        <nat>
          <port start='1024' end='65535'/>
        </nat>
      </forward>
      <bridge name='virbr0' stp='on' delay='0'/>
      <domain name='local'/>
      <ip address='192.168.122.1' netmask='255.255.255.0'>
        <dhcp>
          <range start='192.168.122.2' end='192.168.122.254'/>
        </dhcp>
      </ip>
    </network>
    EOF
    virsh net-start default
  become: yes
  when: default_net_check.stdout == "inactive"
  ignore_errors: yes

- name: Ensure default network is autostarted
  shell: virsh net-autostart default
  become: yes
  ignore_errors: yes

- name: Ensure VM storage directory exists
  file:
    path: "{{ vm_storage_path }}"
    state: directory
    mode: '0755'
  become: yes

- name: Create VM configuration directory
  file:
    path: "/tmp/vm_configs"
    state: directory
    mode: '0755'

- name: Check if bridge interface exists
  command: "ip link show {{ vm_bridge }}"
  register: bridge_check
  changed_when: false
  failed_when: false

- name: Set network config - use bridge if available
  set_fact:
    vm_network_config: "--network bridge={{ vm_bridge }},model=virtio"
  when: bridge_check.rc == 0

- name: Set network config - use default NAT if bridge missing
  set_fact:
    vm_network_config: "--network default,model=virtio"
  when: bridge_check.rc != 0

- name: Display network configuration
  debug:
    msg: "Using network config: {{ vm_network_config }} (bridge_check.rc={{ bridge_check.rc }})"

- name: Generate cloud-init user data for VMs
  template:
    src: cloud-init-user-data.yaml.j2
    dest: "/tmp/vm_configs/user-data-{{ item }}"
    mode: '0644'
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: Check if VMs already exist
  shell: virsh domstate {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} 2>&1
  become: yes
  register: vm_exists
  changed_when: false
  failed_when: false
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: "Creating VM {{ item }}/{{ vms_per_host_safe }}: {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}"
  debug:
    msg: |
      Starting VM creation...
      Name: {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}
      CPUs: {{ vm_cpus_per_instance }}
      Memory: {{ vm_memory_per_instance }} MB
      Disk: {{ vm_disk_size }}
      Network: {{ vm_network_config }}
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: Execute virt-install (background)
  shell: |
    set -e
    echo "=== Creating VM {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} at $(date) ===" >> /tmp/vm_creation_{{ inventory_hostname }}.log
    (virt-install \
      --name {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} \
      --vcpus {{ vm_cpus_per_instance }} \
      --memory {{ vm_memory_per_instance }} \
      --disk path={{ vm_storage_path }}/{{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}.qcow2,size={{ vm_disk_size | regex_replace('[^0-9]', '') }},format=qcow2 \
      {{ vm_network_config }} \
      --os-variant ubuntu22.04 \
      --cloud-init user-data=/tmp/vm_configs/user-data-{{ item }} \
      --graphics none \
      --console pty,target_type=serial \
      --noreboot 2>&1 | tee -a /tmp/vm_creation_{{ inventory_hostname }}.log
    echo "=== Completed VM {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} at $(date) ===" >> /tmp/vm_creation_{{ inventory_hostname }}.log) &
    
    # Store the PID for monitoring
    echo $! > /tmp/virt-install-{{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}.pid
    
    # Wait for the process to complete with timeout
    timeout 120 wait $! || exit 0
  become: yes
  become_user: root
  register: vm_creation
  ignore_errors: yes
  async: 150
  poll: 0
  when: vm_exists.results[item | int - 1].rc != 0
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: "Poll VM {{ item }}/{{ vms_per_host_safe }} creation"
  async_status:
    jid: "{{ vm_creation_result.ansible_job_id }}"
  register: job_result
  until: job_result.finished
  retries: 30
  delay: 5
  ignore_errors: yes
  when: vm_creation_result.ansible_job_id is defined
  loop: "{{ vm_creation.results }}"
  loop_control:
    loop_var: vm_creation_result

- name: "VM {{ item.item }}/{{ vms_per_host_safe }} creation result"
  debug:
    msg: |
      {% if item.rc | default(0) == 0 %}
      VM created successfully
      {% else %}
      ✗ VM creation failed (return code: {{ item.rc | default(-1) }})
      {% endif %}
  loop: "{{ job_result.results }}"

- name: "Starting VM {{ item }}/{{ vms_per_host_safe }}: {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }}"
  debug:
    msg: "Checking VM status..."
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: Check VM status before starting
  shell: |
    virsh domstate {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} 2>&1
  become: yes
  register: vm_state
  ignore_errors: yes
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: Start VM (only if not running)
  shell: |
    virsh start {{ vm_base_name }}-{{ inventory_hostname }}-{{ item.item }} 2>&1 | tee -a /tmp/vm_creation_{{ inventory_hostname }}.log
  become: yes
  register: vm_start
  when: item.stdout != "running"
  loop: "{{ vm_state.results }}"
  ignore_errors: yes

- name: "VM status after startup check"
  debug:
    msg: |
      {% if item.stdout == "running" %}
      ✓ VM {{ item.item }} already running
      {% elif item.rc == 0 %}
      ✓ VM {{ item.item }} started successfully
      {% else %}
      ℹ VM {{ item.item }} status: {{ item.stdout | default('unknown') }}
      {% endif %}
  loop: "{{ vm_state.results }}"

- name: Debug VM and network configuration
  shell: |
    echo "=== VMs Created ==="
    virsh list --all | grep k3s-node
    echo ""
    echo "=== Available Networks ==="
    virsh net-list --all
    echo ""
    echo "=== Default Network Status ==="
    virsh net-info default 2>&1 || echo "Network does not exist"
    echo ""
    echo "=== First VM Network Config ==="
    virsh dumpxml {{ vm_base_name }}-{{ inventory_hostname }}-1 2>/dev/null | grep -A 10 "interface" || echo "VM not found"
    echo ""
    echo "=== Cloud-init Templates Generated ==="
    ls -lh /tmp/vm_configs/user-data-* 2>/dev/null || echo "No cloud-init files found"
  become: yes
  register: debug_output

- name: Display debug info
  debug:
    msg: "{{ debug_output.stdout_lines }}"

- name: "Waiting for VMs to get IP addresses ({{ loop.index }}/{{ vms_per_host_safe }})"
  shell: |
    RESULT=$(virsh domifaddr {{ vm_base_name }}-{{ inventory_hostname }}-{{ item }} 2>/dev/null | grep -oP '[\d.]+(\.[\d.]+){3}' | head -1)
    if [ -z "$RESULT" ]; then
      echo "Waiting for DHCP..." >&2
      exit 1
    fi
    echo "$RESULT"
  become: yes
  register: vm_ip_result
  until: vm_ip_result.stdout != ""
  retries: 30
  delay: 5
  ignore_errors: yes
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list }}"

- name: Display IP addresses acquired
  debug:
    msg: |
      VM IP Addresses:
      {% for result in vm_ip_result.results %}
      {% if result.stdout %}
      VM {{ loop.index }}: {{ result.stdout }}
      {% else %}
      ✗ VM {{ loop.index }}: No IP assigned
      {% endif %}
      {% endfor %}

- name: Collect VM IP addresses
  set_fact:
    vm_ips: "{{ vm_ips | default([]) + [item.stdout] }}"
  loop: "{{ vm_ip_result.results }}"
  when: item.stdout is defined and item.stdout != ""

- name: Add VMs to dynamic inventory
  add_host:
    name: "{{ vm_base_name }}-{{ inventory_hostname }}-{{ item.0 }}"
    ansible_host: "{{ item.1 }}"
    ansible_user: ubuntu
    groups: k3s_cluster
  loop: "{{ range(1, (vms_per_host_safe | int) + 1) | list | zip(vm_ips | default([])) | list }}"

